package org.kniftosoft.util.packet;

import org.kniftosoft.util.Constants;

/**
 * @author julian
 * 
 */
public enum PacketType {

	NULL(0, NULL.class, Constants.bidirectional),
	HANDSHAKE(1, HANDSHAKE.class,Constants.incoming),
	ACCEPT(2, ACCEPT.class, Constants.outgoing),
	LOGIN(10, LOGIN.class, Constants.incoming), 
	AUTH(11, AUTH.class,Constants.outgoing),
	RELOG(12, RELOG.class, Constants.incoming),
	REAUTH(13, REAUTH.class, Constants.outgoing),
	LOGOUT(14, LOGOUT.class,Constants.bidirectional),
	QUERY(20, QUERY.class, Constants.incoming),
	DATA(21, DATA.class, Constants.outgoing),
	SUBSCRIBE(22, SUBSCRIBE.class,Constants.incoming),
	UNSUBSCRIBE(23, UNSUBSCRIBE.class,Constants.incoming),
	CONFIG(50, CONFIG.class, Constants.incoming),
	ACK(200, ACK.class, Constants.bidirectional), 
	NACK(201, NACK.class,Constants.bidirectional), 
	ERROR(242, ERROR.class,Constants.bidirectional);

	
	private int direction;
	private Class<?> packetClass;
	private int typeID;
	
	/**
	 * @param id
	 * @return packet A empty packet generated by the id returns null for a
	 *         invalid packetid
	 */
	public static PacketType byID(int id) {
		System.out.println("male packet by id");
		for (final PacketType packet : PacketType.values()) {
			if (packet.getTypeID() == id) {
				return packet;
			}
		}
		// TODO throw exception
		return null;
	}

	/**
	 * @param typeID
	 * @param packetClass
	 * @param direction
	 */
	private PacketType(int typeID, Class<?> packetClass, int direction) {
		this.typeID = typeID;
		this.packetClass = packetClass;
		this.direction = direction;
	}

	/**
	 * @return direction A Constant witch identify the allowed sending
	 *         directions of the packet
	 */
	public int getDirection() {
		return direction;
	}

	/**
	 * @return packetClass
	 */
	public Class<?> getPacketClass() {
		return packetClass;
	}

	/**
	 * @return typeID
	 */
	public int getTypeID() {
		return typeID;
	}
}
